# Example 04: Signal + Noise with Controls

## Overview

This example adds interactive parameter controls to the signal visualizer, allowing real-time adjustment of frequency, amplitude, and noise level. You'll learn about React hooks, memoization for performance, and controlled components.

**What you'll build:** An interactive signal visualizer with input controls that update the visualization in real-time as parameters change.

## Learning Objectives

By the end of this example, you will be able to:

- Create custom React hooks for signal and noise generation
- Use `useMemo` for performance optimization
- Implement controlled input components
- Handle real-time parameter updates
- Understand React hook dependencies and memoization

## Prerequisites

- Completion of [Example 03](./ex03.md)
- Understanding of React hooks (`useState`, `useEffect`, `useMemo`)
- Familiarity with controlled components

## Key Concepts

### Custom Hooks

**Custom hooks** are functions that use React hooks internally. They encapsulate logic for reuse:

```typescript
function useSignalGenerator(frequency, amplitude, ...) {
  return useMemo(() => {
    return generateSineWave(...);
  }, [frequency, amplitude, ...]);
}
```

**Benefits:**
- Reusable logic
- Separation of concerns
- Easier testing

### Memoization with useMemo

`useMemo` caches expensive computations:

```typescript
const result = useMemo(() => {
  return expensiveCalculation(data);
}, [data]);
```

**When to use:**
- Expensive calculations
- Preventing unnecessary recalculations
- Optimizing render performance

### Controlled Components

**Controlled components** have their values controlled by React state:

```typescript
const [value, setValue] = useState(0);

<Input
  value={value}
  onChange={(e) => setValue(parseFloat(e.target.value))}
/>
```

**Benefits:**
- Single source of truth
- Predictable updates
- Easy validation

## Step-by-Step Guide

### Step 1: Custom Signal Generator Hook

Create a hook that memoizes signal generation:

```typescript
function useSignalGenerator(
  frequency: number,
  amplitude: number,
  phase: number,
  sampleRate: number,
  duration: number
) {
  return useMemo(() => {
    return generateSineWave(frequency, amplitude, phase, sampleRate, duration);
  }, [frequency, amplitude, phase, sampleRate, duration]);
}
```

**Code Explanation:**
- `useMemo`: Caches result until dependencies change
- Dependencies: All parameters that affect signal generation
- Returns: Array of `DataPoint[]`

**Performance Benefit:** Signal only regenerates when parameters actually change.

### Step 2: Custom Noise Generator Hook

Create a hook for adding noise:

```typescript
function useNoiseGenerator(signal: DataPoint[], noiseLevel: number) {
  return useMemo(() => {
    return addNoiseToSignal(signal, noiseLevel);
  }, [signal, noiseLevel]);
}
```

**Code Explanation:**
- Depends on signal array and noise level
- Regenerates when either changes
- Uses memoization to avoid unnecessary recalculations

**Important:** Signal array dependency means it regenerates when signal changes.

### Step 3: Parameter State Management

Use state for each controllable parameter:

```typescript
const [frequency, setFrequency] = useState(1);
const [amplitude, setAmplitude] = useState(1);
const [noiseLevel, setNoiseLevel] = useState(0.2);
```

**Why separate state:**
- Independent updates
- Granular control
- Easy to extend

### Step 4: Using the Hooks

Call hooks with current parameter values:

```typescript
const cleanSignal = useSignalGenerator(frequency, amplitude, 0, 100, 2);
const noisySignal = useNoiseGenerator(cleanSignal, noiseLevel);
```

**Flow:**
1. `useSignalGenerator` creates clean signal from parameters
2. `useNoiseGenerator` adds noise to clean signal
3. Both update automatically when parameters change

### Step 5: Effect Hook for Rendering

Update chart when signals change:

```typescript
useEffect(() => {
  renderChart(svgRef, cleanSignal, noisySignal);
}, [cleanSignal, noisySignal]);
```

**Code Explanation:**
- Depends on signal arrays
- Re-renders chart when signals update
- Automatic visualization updates

### Step 6: Controlled Input Components

Create input fields for each parameter:

```typescript
<div className="space-y-2">
  <Label htmlFor="frequency">Frequency (Hz)</Label>
  <Input
    id="frequency"
    type="number"
    min="0.1"
    max="10"
    step="0.1"
    value={frequency}
    onChange={(e) =>
      setFrequency(parseFloat(e.target.value) || 0)
    }
  />
</div>
```

**Code Explanation:**
- `value`: Controlled by state
- `onChange`: Updates state
- `parseFloat`: Converts string to number
- `|| 0`: Fallback for invalid input

### Step 7: Parameter Display

Show current parameter values:

```typescript
<div className="pt-4 border-t space-y-2 text-sm">
  <div>
    <span className="text-muted-foreground">Frequency: </span>
    <span className="font-mono">{frequency.toFixed(2)} Hz</span>
  </div>
  <div>
    <span className="text-muted-foreground">Amplitude: </span>
    <span className="font-mono">{amplitude.toFixed(2)}</span>
  </div>
  <div>
    <span className="text-muted-foreground">Noise Level: </span>
    <span className="font-mono">{noiseLevel.toFixed(2)}</span>
  </div>
</div>
```

**Code Explanation:**
- Displays formatted parameter values
- `.toFixed(2)`: Two decimal places
- Visual feedback for current settings

## Code Walkthrough

### Complete Component Structure

```typescript
export default function Example04() {
  // State for parameters
  const [frequency, setFrequency] = useState(1);
  const [amplitude, setAmplitude] = useState(1);
  const [noiseLevel, setNoiseLevel] = useState(0.2);
  const svgRef = useRef<SVGSVGElement>(null);

  // Generate signals using hooks
  const cleanSignal = useSignalGenerator(frequency, amplitude, 0, 100, 2);
  const noisySignal = useNoiseGenerator(cleanSignal, noiseLevel);

  // Render chart when signals change
  useEffect(() => {
    renderChart(svgRef, cleanSignal, noisySignal);
  }, [cleanSignal, noisySignal]);

  return (
    <div>
      {/* Parameter controls */}
      {/* Chart display */}
    </div>
  );
}
```

**Data Flow:**
1. User changes input → State updates
2. State change → Hooks recalculate
3. Signal change → Effect re-renders chart
4. Chart updates → User sees new visualization

### Memoization Benefits

**Without `useMemo`:**
- Signal regenerates on every render
- Even if parameters haven't changed
- Unnecessary computation

**With `useMemo`:**
- Signal only regenerates when dependencies change
- Cached between renders
- Better performance

### Hook Dependencies

**Correct dependencies:**
```typescript
useMemo(() => {
  return generateSineWave(frequency, amplitude, phase, sampleRate, duration);
}, [frequency, amplitude, phase, sampleRate, duration]);
```

**Missing dependencies cause:**
- Stale values
- Incorrect calculations
- React warnings

## Exercises

### Exercise 1: Add Phase Control
**Difficulty: Easy**

Add a phase parameter control:
- Add `useState` for phase
- Add input field
- Update `useSignalGenerator` hook call
- Observe phase shift effect

### Exercise 2: Add Sample Rate Control
**Difficulty: Medium**

Add sample rate control:
- Add state and input
- Update hook dependencies
- Observe quality differences
- Add validation (min/max limits)

### Exercise 3: Add Duration Control
**Difficulty: Medium**

Add duration control:
- Add state and input
- Update signal generation
- Observe time span changes
- Consider performance with long durations

### Exercise 4: Parameter Validation
**Difficulty: Medium**

Add input validation:
- Ensure values are within valid ranges
- Show error messages for invalid inputs
- Prevent invalid state updates
- Add helpful hints

### Exercise 5: Parameter Presets
**Difficulty: Hard**

Add preset buttons:
- "Low Frequency": 0.5 Hz
- "High Frequency": 5 Hz
- "Low Noise": 0.1
- "High Noise": 0.5
- Apply all parameters at once

## Solutions/Hints

### Exercise 1 Solution
```typescript
const [phase, setPhase] = useState(0);
const cleanSignal = useSignalGenerator(frequency, amplitude, phase, 100, 2);
```

### Exercise 2 Hint
Add validation:
```typescript
const handleSampleRateChange = (value: number) => {
  const clamped = Math.max(10, Math.min(1000, value));
  setSampleRate(clamped);
};
```

### Exercise 3 Hint
Consider performance:
- High sample rates × long durations = many data points
- May need to limit maximum values
- Consider debouncing for very frequent updates

### Exercise 4 Hint
Create validation function:
```typescript
const validateFrequency = (value: number): boolean => {
  return value >= 0.1 && value <= 10;
};
```

### Exercise 5 Hint
Create preset object:
```typescript
const presets = {
  lowFreq: { frequency: 0.5, amplitude: 1, noiseLevel: 0.2 },
  // ...
};

const applyPreset = (preset: typeof presets.lowFreq) => {
  setFrequency(preset.frequency);
  setAmplitude(preset.amplitude);
  setNoiseLevel(preset.noiseLevel);
};
```

## Summary

In this example, you learned:

1. **Custom Hooks**: Creating reusable signal generation logic
2. **Memoization**: Using `useMemo` for performance optimization
3. **Controlled Components**: Managing input values with React state
4. **Real-time Updates**: Updating visualizations based on parameter changes
5. **Hook Dependencies**: Understanding when hooks recalculate

**Key Takeaways:**
- Custom hooks encapsulate reusable logic
- `useMemo` prevents unnecessary recalculations
- Controlled components provide predictable state management
- Proper dependencies ensure correct hook behavior
- Real-time updates create interactive experiences

## Next Steps

- **Example 05**: Build a complete visualizer with modular architecture
- **Experiment**: Add more parameters and controls
- **Extend**: Implement parameter saving/loading

---

**Ready for the final challenge?** Continue to [Example 05: Full Signal Visualizer](./ex05.md)

