# Example 02: Signal with Noise

## Overview

This example extends Example 01 by adding Gaussian noise to the signal and visualizing both the clean signal and the noisy signal side by side. You'll learn about noise generation, signal processing, and dual visualization techniques.

**What you'll build:** An application that generates a sine wave, adds Gaussian noise to it, and displays both signals in separate charts for comparison.

## Learning Objectives

By the end of this example, you will be able to:

- Generate Gaussian (normal) noise using the Box-Muller transform
- Add noise to signals with controllable noise levels
- Create dual visualizations for comparison
- Understand signal-to-noise ratio concepts
- Implement reusable chart rendering functions

## Prerequisites

- Completion of [Example 01](./ex01.md)
- Understanding of probability distributions (basic)
- Familiarity with D3.js scales and axes

## Key Concepts

### Gaussian Noise

**Gaussian noise** (also called white noise or normal noise) is random noise that follows a normal (Gaussian) distribution. It's characterized by:

- **Mean (μ)**: Average value (typically 0)
- **Standard Deviation (σ)**: Spread of values (noise level)

**Properties:**
- Values cluster around the mean
- Symmetric distribution
- Common in real-world sensor data

### Box-Muller Transform

The Box-Muller transform converts uniform random numbers to normally distributed random numbers:

```
z0 = √(-2 × ln(u1)) × cos(2π × u2)
```

Where `u1` and `u2` are independent uniform random numbers (0 to 1).

### Signal + Noise

When noise is added to a signal:

```
noisy_signal = clean_signal + noise
```

The **noise level** controls the standard deviation of the noise distribution.

### Signal-to-Noise Ratio (SNR)

SNR measures signal quality:
- **High SNR**: Signal is clear, noise is minimal
- **Low SNR**: Signal is obscured by noise

## Step-by-Step Guide

### Step 1: Gaussian Noise Generation

The `generateGaussianNoise()` function creates an array of random noise values:

```typescript
function generateGaussianNoise(
  length: number,
  mean: number = 0,
  stdDev: number = 0.1
): number[] {
  const noise: number[] = [];
  for (let i = 0; i < length; i++) {
    // Box-Muller transform
    const u1 = Math.random();
    const u2 = Math.random();
    const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    noise.push(mean + z0 * stdDev);
  }
  return noise;
}
```

**Code Explanation:**
- Line 4: Initialize empty array
- Line 5: Loop for desired number of samples
- Line 7-8: Generate two uniform random numbers
- Line 9: Apply Box-Muller transform
- Line 10: Scale by standard deviation and shift by mean
- Line 11: Store noise value

**Mathematical Note:** The Box-Muller transform generates two independent normal random variables. We use only one (`z0`).

### Step 2: Adding Noise to Signal

The `addNoiseToSignal()` function combines a clean signal with noise:

```typescript
function addNoiseToSignal(
  signal: DataPoint[],
  noiseLevel: number = 0.1
): DataPoint[] {
  const noise = generateGaussianNoise(signal.length, 0, noiseLevel);
  return signal.map((point, i) => ({
    time: point.time,
    value: point.value + noise[i],
  }));
}
```

**Code Explanation:**
- Line 4: Generate noise array matching signal length
- Line 5-8: Map each signal point, adding corresponding noise value
- Preserves time values, modifies only amplitude values

### Step 3: Dual Chart Rendering

Create a reusable `renderChart()` function that handles both clean and noisy signals:

```typescript
function renderChart(
  svgRef: React.RefObject<SVGSVGElement | null>,
  cleanData: DataPoint[],
  noisyData: DataPoint[],
  title: string,
  color: string
) {
  if (!svgRef.current) return;

  const svg = d3.select(svgRef.current);
  svg.selectAll("*").remove();

  // Setup dimensions (same as Example 01)
  const width = 800;
  const height = 300;
  const margin = { top: 20, right: 30, bottom: 40, left: 60 };
  // ... (scales setup)

  // Combine data for domain calculation
  const allData = [...cleanData, ...noisyData];
  const xScale = d3
    .scaleLinear()
    .domain(d3.extent(allData, (d) => d.time) as [number, number])
    .range([0, chartWidth]);

  const yScale = d3
    .scaleLinear()
    .domain(d3.extent(allData, (d) => d.value) as [number, number])
    .range([chartHeight, 0])
    .nice();
```

**Code Explanation:**
- Line 1-6: Function signature with ref and data parameters
- Line 8: Early return if ref not available
- Line 11: Combine both datasets for unified scale domain
- Ensures both signals are visible on same scale

### Step 4: Drawing Both Signals

Render clean signal and noisy signal on the same chart:

```typescript
// Draw clean signal
g.append("path")
  .datum(cleanData)
  .attr("fill", "none")
  .attr("stroke", color)
  .attr("stroke-width", 2)
  .attr("d", line);

// Draw noisy signal
g.append("path")
  .datum(noisyData)
  .attr("fill", "none")
  .attr("stroke", "#ef4444")
  .attr("stroke-width", 1.5)
  .attr("opacity", 0.7)
  .attr("d", line);
```

**Code Explanation:**
- Clean signal: Thicker line (2px), full opacity, primary color
- Noisy signal: Thinner line (1.5px), reduced opacity (0.7), red color
- Both use same line generator with different data

### Step 5: Add Legend

Create a legend to identify the signals:

```typescript
const legend = g
  .append("g")
  .attr("transform", `translate(${chartWidth - 150}, 20)`);

legend
  .append("line")
  .attr("x1", 0)
  .attr("x2", 30)
  .attr("y1", 0)
  .attr("y2", 0)
  .attr("stroke", color)
  .attr("stroke-width", 2);

legend
  .append("text")
  .attr("x", 35)
  .attr("y", 4)
  .attr("fill", "currentColor")
  .style("font-size", "14px")
  .text("Clean Signal");

// Similar for noisy signal
```

**Code Explanation:**
- Position legend in top-right corner
- Draw sample lines matching signal styles
- Add text labels

### Step 6: Component Structure

The main component renders two separate charts:

```typescript
export default function Example02() {
  const cleanSvgRef = useRef<SVGSVGElement>(null);
  const noisySvgRef = useRef<SVGSVGElement>(null);

  useEffect(() => {
    // Generate signals
    const cleanSignal = generateSineWave(1, 1, 0, 100, 2);
    const noisySignal = addNoiseToSignal(cleanSignal, 0.2);

    // Render charts
    renderChart(cleanSvgRef, cleanSignal, cleanSignal, "Clean Signal", "#3b82f6");
    renderChart(noisySvgRef, cleanSignal, noisySignal, "Signal + Noise", "#3b82f6");
  }, []);

  return (
    <div>
      <div>
        <h2>Clean Signal</h2>
        <svg ref={cleanSvgRef} className="w-full" viewBox="0 0 800 300" />
      </div>
      <div>
        <h2>Signal + Noise</h2>
        <svg ref={noisySvgRef} className="w-full" viewBox="0 0 800 300" />
      </div>
    </div>
  );
}
```

**Code Explanation:**
- Two separate refs for two charts
- First chart shows clean signal only (for reference)
- Second chart shows both signals for comparison

## Code Walkthrough

### Noise Generation Algorithm

The Box-Muller transform is a standard method for generating normal random variables:

```typescript
const u1 = Math.random();  // Uniform [0, 1)
const u2 = Math.random();  // Uniform [0, 1)
const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
// z0 is now normally distributed with mean=0, stdDev=1
```

**Why it works:**
- `-2 * Math.log(u1)` ensures positive values
- `Math.cos(2π × u2)` provides uniform angle distribution
- Product creates normal distribution

### Signal Combination

When combining signals, we preserve the time axis:

```typescript
signal.map((point, i) => ({
  time: point.time,           // Preserve time
  value: point.value + noise[i]  // Add noise to amplitude
}))
```

This ensures time alignment between clean and noisy signals.

## Exercises

### Exercise 1: Adjust Noise Level
**Difficulty: Easy**

Modify the noise level in `addNoiseToSignal()`:
- Try `0.05` (low noise)
- Try `0.5` (high noise)
- Observe the effect on signal visibility

### Exercise 2: Change Noise Distribution
**Difficulty: Medium**

Modify `generateGaussianNoise()` to use uniform noise instead:
- Replace Box-Muller with uniform random: `Math.random() * 2 - 1`
- Compare the visual difference

### Exercise 3: Calculate Signal Statistics
**Difficulty: Medium**

Add calculations to display:
- Mean of clean signal
- Mean of noisy signal
- Standard deviation of noise
- Signal-to-noise ratio

### Exercise 4: Add Noise Level Control
**Difficulty: Hard**

Add a slider or input to dynamically change noise level:
- Use `useState` for noise level
- Regenerate noisy signal when level changes
- Update visualization in real-time

### Exercise 5: Multiple Noise Levels
**Difficulty: Hard**

Display multiple charts with different noise levels:
- Create charts for noise levels: 0.1, 0.2, 0.3, 0.5
- Compare signal degradation across levels

## Solutions/Hints

### Exercise 1 Solution
```typescript
const noisySignal = addNoiseToSignal(cleanSignal, 0.5);
```

### Exercise 2 Hint
Uniform noise creates a "flat" distribution, while Gaussian noise clusters around zero.

### Exercise 3 Hint
Use array methods:
```typescript
const mean = data.reduce((sum, d) => sum + d.value, 0) / data.length;
const variance = data.reduce((sum, d) => sum + Math.pow(d.value - mean, 2), 0) / data.length;
const stdDev = Math.sqrt(variance);
```

### Exercise 4 Hint
Add state and update effect dependencies:
```typescript
const [noiseLevel, setNoiseLevel] = useState(0.2);
useEffect(() => {
  // Regenerate with current noise level
}, [noiseLevel]);
```

### Exercise 5 Hint
Create an array of noise levels and map to create multiple charts.

## Summary

In this example, you learned:

1. **Noise Generation**: Creating Gaussian noise using Box-Muller transform
2. **Signal Processing**: Adding noise to clean signals
3. **Dual Visualization**: Comparing clean and noisy signals
4. **Reusable Functions**: Creating chart rendering functions
5. **Signal Quality**: Understanding noise impact on signals

**Key Takeaways:**
- Gaussian noise follows a normal distribution
- Box-Muller transform generates normal random variables
- Noise level controls signal quality
- Visual comparison helps understand noise effects

## Next Steps

- **Example 03**: Learn to generate multiple signal types (square, sawtooth)
- **Experiment**: Try different noise distributions and levels
- **Extend**: Add noise filtering or signal processing techniques

---

**Ready for the next challenge?** Continue to [Example 03: Multiple Signal Types](./ex03.md)

