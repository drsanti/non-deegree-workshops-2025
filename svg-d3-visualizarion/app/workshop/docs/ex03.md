# Example 03: Multiple Signal Types

## Overview

This example expands signal generation to support multiple waveform types: sine, square, and sawtooth waves. You'll learn how to implement different signal generation algorithms and create a UI for switching between signal types.

**What you'll build:** An application that can generate and visualize three different signal types with a simple button-based selector interface.

## Learning Objectives

By the end of this example, you will be able to:

- Generate square waves and sawtooth waves
- Implement a signal type selector using React state
- Understand the mathematical differences between waveform types
- Create a unified signal generation function
- Handle state changes to update visualizations

## Prerequisites

- Completion of [Example 02](./ex02.md)
- Understanding of signal generation basics
- Familiarity with React state management (`useState`)

## Key Concepts

### Waveform Types

Different waveforms have distinct characteristics:

**Sine Wave:**
- Smooth, continuous oscillation
- Formula: `amplitude × sin(2π × frequency × time + phase)`
- Used in: Audio synthesis, AC power

**Square Wave:**
- Alternates between two constant values
- Formula: `amplitude × sign(sin(2π × frequency × time + phase))`
- Used in: Digital signals, clock signals

**Sawtooth Wave:**
- Linear rise followed by sharp drop
- Formula: `amplitude × (2 × normalized_time - 1)`
- Used in: Music synthesis, oscilloscopes

### Signal Type Selection

Using React state to manage signal type:

```typescript
const [signalType, setSignalType] = useState<SignalType>("sine");
```

State changes trigger re-generation and re-rendering of the signal.

### Unified Generation Function

A single function dispatches to type-specific generators:

```typescript
function generateSignal(
  type: SignalType,
  frequency: number,
  amplitude: number,
  // ... other params
): DataPoint[] {
  switch (type) {
    case "sine": return generateSineWave(...);
    case "square": return generateSquareWave(...);
    case "sawtooth": return generateSawtoothWave(...);
  }
}
```

## Step-by-Step Guide

### Step 1: Square Wave Generation

Square waves alternate between maximum positive and negative values:

```typescript
function generateSquareWave(
  frequency: number,
  amplitude: number,
  phase: number,
  sampleRate: number,
  duration: number
): DataPoint[] {
  const dataPoints: DataPoint[] = [];
  const numSamples = Math.floor(sampleRate * duration);
  const timeStep = 1 / sampleRate;

  for (let i = 0; i < numSamples; i++) {
    const time = i * timeStep;
    const sineValue = Math.sin(2 * Math.PI * frequency * time + phase);
    const value = amplitude * Math.sign(sineValue);
    dataPoints.push({ time, value });
  }

  return dataPoints;
}
```

**Code Explanation:**
- Line 9: Calculate sine value (used as reference)
- Line 10: `Math.sign()` returns -1, 0, or 1
  - Positive sine → +1 → +amplitude
  - Negative sine → -1 → -amplitude
- Result: Square wave alternating between ±amplitude

**Mathematical Note:** Square waves can be generated from sine waves using the sign function, which creates the characteristic square shape.

### Step 2: Sawtooth Wave Generation

Sawtooth waves have a linear rise and sharp drop:

```typescript
function generateSawtoothWave(
  frequency: number,
  amplitude: number,
  phase: number,
  sampleRate: number,
  duration: number
): DataPoint[] {
  const dataPoints: DataPoint[] = [];
  const numSamples = Math.floor(sampleRate * duration);
  const timeStep = 1 / sampleRate;

  for (let i = 0; i < numSamples; i++) {
    const time = i * timeStep;
    const normalizedTime = (time * frequency + phase / (2 * Math.PI)) % 1;
    const value = amplitude * (2 * normalizedTime - 1);
    dataPoints.push({ time, value });
  }

  return dataPoints;
}
```

**Code Explanation:**
- Line 10: Normalize time to [0, 1) range within each cycle
  - `time * frequency`: Number of cycles elapsed
  - `% 1`: Fractional part (position within current cycle)
  - `phase / (2π)`: Phase offset in cycles
- Line 11: Map normalized time to [-amplitude, +amplitude]
  - `2 × normalizedTime - 1`: Maps [0, 1) to [-1, 1)
  - Multiply by amplitude for final range

**Visual Pattern:** Linear increase from -amplitude to +amplitude, then instant drop back to -amplitude.

### Step 3: Unified Signal Generator

Create a function that dispatches to the appropriate generator:

```typescript
type SignalType = "sine" | "square" | "sawtooth";

function generateSignal(
  type: SignalType,
  frequency: number,
  amplitude: number,
  phase: number,
  sampleRate: number,
  duration: number
): DataPoint[] {
  switch (type) {
    case "sine":
      return generateSineWave(frequency, amplitude, phase, sampleRate, duration);
    case "square":
      return generateSquareWave(frequency, amplitude, phase, sampleRate, duration);
    case "sawtooth":
      return generateSawtoothWave(frequency, amplitude, phase, sampleRate, duration);
  }
}
```

**Code Explanation:**
- Type-safe union type for signal types
- Switch statement routes to appropriate generator
- All generators share the same signature

### Step 4: Signal Type State Management

Use React state to track the selected signal type:

```typescript
const [signalType, setSignalType] = useState<SignalType>("sine");
```

**State Updates:**
- Initial value: "sine" (default)
- Updates trigger re-generation in `useEffect`

### Step 5: Effect Hook with Signal Type Dependency

Regenerate signal when type changes:

```typescript
useEffect(() => {
  const frequency = 1;
  const amplitude = 1;
  const phase = 0;
  const sampleRate = 100;
  const duration = 2;

  const data = generateSignal(
    signalType,
    frequency,
    amplitude,
    phase,
    sampleRate,
    duration
  );

  renderChart(svgRef, data, signalColors[signalType]);
}, [signalType]);
```

**Code Explanation:**
- `signalType` in dependency array: Re-runs when type changes
- Generate signal using current type
- Render with type-specific color

### Step 6: UI Buttons for Type Selection

Create buttons to switch between signal types:

```typescript
<div className="mb-6 flex gap-4">
  <Button
    variant={signalType === "sine" ? "default" : "outline"}
    onClick={() => setSignalType("sine")}
  >
    Sine Wave
  </Button>
  <Button
    variant={signalType === "square" ? "default" : "outline"}
    onClick={() => setSignalType("square")}
  >
    Square Wave
  </Button>
  <Button
    variant={signalType === "sawtooth" ? "default" : "outline"}
    onClick={() => setSignalType("sawtooth")}
  >
    Sawtooth Wave
  </Button>
</div>
```

**Code Explanation:**
- Conditional `variant`: Highlights active button
- `onClick`: Updates state, triggering re-render
- Visual feedback shows current selection

### Step 7: Color Mapping

Assign different colors to each signal type:

```typescript
const signalColors: Record<SignalType, string> = {
  sine: "#3b82f6",      // Blue
  square: "#ef4444",     // Red
  sawtooth: "#10b981",  // Green
};
```

**Usage:**
```typescript
renderChart(svgRef, data, signalColors[signalType]);
```

## Code Walkthrough

### Complete Component Structure

```typescript
export default function Example03() {
  const [signalType, setSignalType] = useState<SignalType>("sine");
  const svgRef = useRef<SVGSVGElement>(null);

  useEffect(() => {
    // Generate signal based on current type
    const data = generateSignal(signalType, 1, 1, 0, 100, 2);
    
    // Render with type-specific color
    renderChart(svgRef, data, signalColors[signalType]);
  }, [signalType]);  // Re-run when type changes

  return (
    <div>
      {/* Type selector buttons */}
      {/* Chart display */}
    </div>
  );
}
```

**Key Points:**
- State drives signal generation
- Effect depends on signal type
- UI updates reflect state changes

### Signal Generation Comparison

**Sine Wave:**
- Smooth curve
- Continuous derivative
- Natural oscillation

**Square Wave:**
- Sharp transitions
- Discontinuous derivative
- Digital-like behavior

**Sawtooth Wave:**
- Linear segments
- Periodic discontinuities
- Ramp-like pattern

## Exercises

### Exercise 1: Add Triangle Wave
**Difficulty: Medium**

Implement a triangle wave generator:
- Similar to sawtooth but symmetric
- Rises linearly, then falls linearly
- Formula: Use absolute value of sawtooth

### Exercise 2: Modify Square Wave Duty Cycle
**Difficulty: Medium**

Add a duty cycle parameter to square wave:
- Control ratio of high to low time
- Default: 50% (equal high/low)
- Try: 25%, 75% duty cycles

### Exercise 3: Add Signal Type Info Display
**Difficulty: Easy**

Display information about the current signal type:
- Show formula or description
- Display characteristic properties
- Add visual indicators

### Exercise 4: Combine Multiple Signals
**Difficulty: Hard**

Allow displaying multiple signal types simultaneously:
- Generate all three types
- Overlay them on same chart
- Use different colors/styles

### Exercise 5: Signal Type Presets
**Difficulty: Medium**

Create preset parameter combinations:
- "Audio" preset: Sine wave, 440 Hz
- "Digital" preset: Square wave, 1 Hz
- "Test" preset: Sawtooth, 2 Hz
- Add preset selector dropdown

## Solutions/Hints

### Exercise 1 Hint
Triangle wave can be generated from sawtooth:
```typescript
const sawtoothValue = 2 * normalizedTime - 1;
const triangleValue = 2 * Math.abs(sawtoothValue) - 1;
```

### Exercise 2 Hint
Modify square wave to use threshold:
```typescript
const threshold = dutyCycle / 100;
const value = sineValue > Math.cos(2 * Math.PI * threshold) 
  ? amplitude 
  : -amplitude;
```

### Exercise 3 Hint
Create an info object:
```typescript
const signalInfo = {
  sine: { formula: "A × sin(2πft + φ)", description: "Smooth oscillation" },
  // ...
};
```

### Exercise 4 Hint
Generate all signals and render multiple paths:
```typescript
const sineData = generateSineWave(...);
const squareData = generateSquareWave(...);
// Render all on same chart
```

### Exercise 5 Hint
Create preset objects and use them:
```typescript
const presets = {
  audio: { type: "sine", frequency: 440, ... },
  // ...
};
```

## Summary

In this example, you learned:

1. **Multiple Waveforms**: Generating sine, square, and sawtooth waves
2. **Signal Algorithms**: Mathematical approaches for different waveforms
3. **State Management**: Using React state for signal type selection
4. **Unified Interface**: Creating a single function for multiple generators
5. **UI Interaction**: Button-based type switching

**Key Takeaways:**
- Different waveforms have distinct mathematical properties
- Square waves use sign function on sine values
- Sawtooth waves use modulo arithmetic for periodic ramps
- State changes trigger signal regeneration
- Type-safe enums ensure correct signal types

## Next Steps

- **Example 04**: Add interactive parameter controls
- **Experiment**: Try different waveform combinations
- **Extend**: Implement additional waveform types (triangle, pulse)

---

**Ready for the next challenge?** Continue to [Example 04: Signal + Noise with Controls](./ex04.md)

