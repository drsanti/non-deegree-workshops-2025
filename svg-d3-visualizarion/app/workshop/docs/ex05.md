# Example 05: Full Signal Visualizer

## Overview

This example brings together all concepts from previous examples into a complete, production-ready signal visualizer. You'll learn about component architecture, code organization, separation of concerns, and building a full-featured application with a tabbed interface.

**What you'll build:** A complete signal visualizer with multiple signal types, noise generation, full parameter controls, and a modular component architecture.

## Learning Objectives

By the end of this example, you will be able to:

- Organize code into reusable components and hooks
- Separate concerns (generation, visualization, controls)
- Build a tabbed interface for multiple signal types
- Create a maintainable, scalable codebase
- Apply React best practices for component architecture

## Prerequisites

- Completion of [Example 04](./ex04.md)
- Understanding of component composition
- Familiarity with TypeScript interfaces and types
- Knowledge of code organization principles

## Key Concepts

### Component Architecture

**Separation of Concerns:**
- **Components**: UI and presentation logic
- **Hooks**: Data generation and state management
- **Utilities**: Pure functions and algorithms
- **Types**: Type definitions and interfaces

### Modular Design

**Benefits:**
- Reusability: Components can be used in multiple places
- Maintainability: Easy to find and modify code
- Testability: Components can be tested independently
- Scalability: Easy to add new features

### Code Organization

**File Structure:**
```
ex05/
â”œâ”€â”€ components/        # UI components
â”œâ”€â”€ hooks/            # Custom hooks
â”œâ”€â”€ lib/              # Utilities and types
â”œâ”€â”€ layout.tsx         # Page layout
â””â”€â”€ page.tsx          # Main page component
```

## Step-by-Step Guide

### Step 1: Type Definitions

Create shared type definitions in `lib/types.ts`:

```typescript
export interface DataPoint {
  time: number;
  value: number;
}

export type SignalType = "sine" | "square" | "sawtooth";

export interface SignalParams {
  frequency: number;
  amplitude: number;
  phase: number;
  sampleRate: number;
  duration: number;
  noiseLevel: number;
}
```

**Benefits:**
- Single source of truth for types
- Type safety across components
- Easy to extend

### Step 2: Signal Generators

Extract signal generation to `lib/signal-generators.ts`:

```typescript
export function generateSineWave(params: SignalParams): DataPoint[] {
  const { frequency, amplitude, phase, sampleRate, duration } = params;
  // ... implementation
}

export function generateSquareWave(params: SignalParams): DataPoint[] {
  // ... implementation
}

export function generateSawtoothWave(params: SignalParams): DataPoint[] {
  // ... implementation
}

export function generateSignal(
  type: SignalType,
  params: SignalParams
): DataPoint[] {
  switch (type) {
    case "sine": return generateSineWave(params);
    case "square": return generateSquareWave(params);
    case "sawtooth": return generateSawtoothWave(params);
  }
}
```

**Benefits:**
- Pure functions (no side effects)
- Easy to test
- Reusable across components

### Step 3: Noise Generators

Extract noise generation to `lib/noise-generators.ts`:

```typescript
export function generateGaussianNoise(
  length: number,
  mean: number = 0,
  stdDev: number = 0.1
): number[] {
  // ... Box-Muller implementation
}

export function addNoiseToSignal(
  signal: DataPoint[],
  noiseLevel: number = 0.1
): DataPoint[] {
  const noise = generateGaussianNoise(signal.length, 0, noiseLevel);
  return signal.map((point, i) => ({
    time: point.time,
    value: point.value + noise[i],
  }));
}
```

**Benefits:**
- Separated concerns
- Testable independently
- Reusable

### Step 4: Utility Functions

Create utilities in `lib/utils.ts`:

```typescript
export function getDefaultParams(): SignalParams {
  return {
    frequency: 1,
    amplitude: 1,
    phase: 0,
    sampleRate: 100,
    duration: 2,
    noiseLevel: 0.2,
  };
}

export function degreesToRadians(degrees: number): number {
  return (degrees * Math.PI) / 180;
}

export function radiansToDegrees(radians: number): number {
  return (radians * 180) / Math.PI;
}

export const signalColors: Record<string, string> = {
  sine: "#3b82f6",
  square: "#ef4444",
  sawtooth: "#10b981",
};
```

**Benefits:**
- Centralized defaults
- Reusable conversions
- Consistent colors

### Step 5: Custom Hooks

Create hooks in `hooks/useSignalGenerator.ts` and `hooks/useNoiseGenerator.ts`:

```typescript
// hooks/useSignalGenerator.ts
export function useSignalGenerator(
  type: SignalType,
  params: SignalParams
): DataPoint[] {
  return useMemo(() => {
    return generateSignal(type, params);
  }, [type, params]);
}

// hooks/useNoiseGenerator.ts
export function useNoiseGenerator(
  signal: DataPoint[],
  noiseLevel: number
): DataPoint[] {
  return useMemo(() => {
    return addNoiseToSignal(signal, noiseLevel);
  }, [signal, noiseLevel]);
}
```

**Benefits:**
- Encapsulated logic
- Memoization built-in
- Easy to use in components

### Step 6: SignalChart Component

Create chart component in `components/SignalChart.tsx`:

```typescript
interface SignalChartProps {
  cleanData: DataPoint[];
  noisyData: DataPoint[];
  color: string;
  width?: number;
  height?: number;
}

export default function SignalChart({
  cleanData,
  noisyData,
  color,
  width = 1000,
  height = 400,
}: SignalChartProps) {
  const svgRef = useRef<SVGSVGElement>(null);

  useEffect(() => {
    // D3.js rendering logic
  }, [cleanData, noisyData, color, width, height]);

  return (
    <svg ref={svgRef} className="w-full" viewBox={`0 0 ${width} ${height}`} />
  );
}
```

**Benefits:**
- Reusable visualization
- Props-based configuration
- Encapsulated D3.js logic

### Step 7: SignalControls Component

Create controls component in `components/SignalControls.tsx`:

```typescript
interface SignalControlsProps {
  params: SignalParams;
  onParamsChange: (params: SignalParams) => void;
  signalType: string;
}

export default function SignalControls({
  params,
  onParamsChange,
  signalType,
}: SignalControlsProps) {
  const updateParam = (key: keyof SignalParams, value: number) => {
    onParamsChange({ ...params, [key]: value });
  };

  return (
    <Card>
      {/* Input fields for all parameters */}
    </Card>
  );
}
```

**Benefits:**
- Reusable controls
- Type-safe parameter updates
- Consistent UI

### Step 8: SignalTab Component

Create tab content component in `components/SignalTab.tsx`:

```typescript
interface SignalTabProps {
  signalType: string;
  params: SignalParams;
  onParamsChange: (params: SignalParams) => void;
  cleanSignal: DataPoint[];
  noisySignal: DataPoint[];
}

export default function SignalTab({
  signalType,
  params,
  onParamsChange,
  cleanSignal,
  noisySignal,
}: SignalTabProps) {
  const color = signalColors[signalType] || "#3b82f6";

  return (
    <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
      <SignalControls
        params={params}
        onParamsChange={onParamsChange}
        signalType={signalType}
      />
      <div className="lg:col-span-2">
        <Card>
          <SignalChart
            cleanData={cleanSignal}
            noisyData={noisySignal}
            color={color}
          />
        </Card>
      </div>
    </div>
  );
}
```

**Benefits:**
- Composes smaller components
- Handles layout
- Type-specific configuration

### Step 9: Main Page Component

Create main page in `page.tsx`:

```typescript
export default function Example05() {
  const [activeTab, setActiveTab] = useState<SignalType>("sine");
  
  // Separate state for each signal type
  const [sineParams, setSineParams] = useState<SignalParams>(
    getDefaultParams()
  );
  const [squareParams, setSquareParams] = useState<SignalParams>(
    getDefaultParams()
  );
  const [sawtoothParams, setSawtoothParams] = useState<SignalParams>(
    getDefaultParams()
  );

  // Generate signals using hooks
  const sineSignal = useSignalGenerator("sine", sineParams);
  const squareSignal = useSignalGenerator("square", squareParams);
  const sawtoothSignal = useSignalGenerator("sawtooth", sawtoothParams);

  // Generate noisy signals
  const sineNoisy = useNoiseGenerator(sineSignal, sineParams.noiseLevel);
  const squareNoisy = useNoiseGenerator(squareSignal, squareParams.noiseLevel);
  const sawtoothNoisy = useNoiseGenerator(
    sawtoothSignal,
    sawtoothParams.noiseLevel
  );

  return (
    <div>
      <Tabs value={activeTab} onValueChange={(v) => setActiveTab(v as SignalType)}>
        <TabsList>
          <TabsTrigger value="sine">Sine Wave</TabsTrigger>
          <TabsTrigger value="square">Square Wave</TabsTrigger>
          <TabsTrigger value="sawtooth">Sawtooth Wave</TabsTrigger>
        </TabsList>

        <TabsContent value="sine">
          <SignalTab
            signalType="sine"
            params={sineParams}
            onParamsChange={setSineParams}
            cleanSignal={sineSignal}
            noisySignal={sineNoisy}
          />
        </TabsContent>

        {/* Similar for square and sawtooth */}
      </Tabs>
    </div>
  );
}
```

**Benefits:**
- Clean, readable main component
- Separated concerns
- Easy to understand flow

## Code Walkthrough

### Architecture Overview

```
page.tsx (Orchestration)
  â”œâ”€â”€ State Management (tabs, parameters)
  â”œâ”€â”€ Signal Generation (hooks)
  â””â”€â”€ UI Composition (Tabs, SignalTab)

SignalTab (Composition)
  â”œâ”€â”€ SignalControls (Inputs)
  â””â”€â”€ SignalChart (Visualization)

Hooks (Logic)
  â”œâ”€â”€ useSignalGenerator
  â””â”€â”€ useNoiseGenerator

Lib (Utilities)
  â”œâ”€â”€ signal-generators.ts
  â”œâ”€â”€ noise-generators.ts
  â””â”€â”€ utils.ts
```

### Component Hierarchy

```
Example05 (Page)
  â””â”€â”€ Tabs (Container)
      â”œâ”€â”€ TabsList (Navigation)
      â””â”€â”€ TabsContent (Content)
          â””â”€â”€ SignalTab (Layout)
              â”œâ”€â”€ SignalControls (Inputs)
              â””â”€â”€ SignalChart (Visualization)
```

### Data Flow

1. **User Input** â†’ `SignalControls` â†’ `onParamsChange`
2. **State Update** â†’ `params` state changes
3. **Hook Recalculation** â†’ `useSignalGenerator` regenerates signal
4. **Noise Addition** â†’ `useNoiseGenerator` adds noise
5. **Visualization Update** â†’ `SignalChart` re-renders

### State Management Strategy

**Separate State per Signal Type:**
- Each signal type maintains its own parameters
- Switching tabs preserves parameter values
- Independent control per signal type

**Benefits:**
- Better user experience
- No parameter conflicts
- Easy to compare different configurations

## Exercises

### Exercise 1: Add Export Functionality
**Difficulty: Medium**

Add ability to export signal data:
- Export as CSV
- Export as JSON
- Add download button

### Exercise 2: Add Parameter Presets
**Difficulty: Medium**

Create preset configurations:
- "Audio" preset for sine wave
- "Digital" preset for square wave
- "Test" preset for sawtooth
- Add preset selector

### Exercise 3: Add Signal Comparison View
**Difficulty: Hard**

Create a comparison mode:
- Display all three signals on one chart
- Use different colors/styles
- Add toggle for comparison mode

### Exercise 4: Add Real-time Updates
**Difficulty: Hard**

Implement real-time signal generation:
- Continuously update signal
- Add play/pause controls
- Adjustable update rate

### Exercise 5: Add Signal Analysis
**Difficulty: Hard**

Add signal analysis features:
- Calculate RMS (Root Mean Square)
- Display frequency spectrum
- Show signal statistics

## Solutions/Hints

### Exercise 1 Hint
```typescript
const exportToCSV = (data: DataPoint[]) => {
  const csv = data.map(d => `${d.time},${d.value}`).join('\n');
  const blob = new Blob([csv], { type: 'text/csv' });
  // Create download link
};
```

### Exercise 2 Hint
Create preset object:
```typescript
const presets = {
  audio: { frequency: 440, amplitude: 1, ... },
  digital: { frequency: 1, amplitude: 1, ... },
};
```

### Exercise 3 Hint
Create comparison component that accepts multiple signals and renders them together.

### Exercise 4 Hint
Use `setInterval` or `requestAnimationFrame` for continuous updates. Add state for play/pause.

### Exercise 5 Hint
Implement analysis functions:
```typescript
function calculateRMS(data: DataPoint[]): number {
  const sumSquares = data.reduce((sum, d) => sum + d.value * d.value, 0);
  return Math.sqrt(sumSquares / data.length);
}
```

## Summary

In this example, you learned:

1. **Component Architecture**: Organizing code into reusable components
2. **Separation of Concerns**: Dividing logic into appropriate modules
3. **Code Organization**: Structuring files for maintainability
4. **Component Composition**: Building complex UIs from simple parts
5. **State Management**: Managing multiple independent states

**Key Takeaways:**
- Modular architecture improves maintainability
- Separation of concerns makes code testable
- Component composition enables reusability
- Proper organization scales with complexity
- Type safety ensures correctness

**Architecture Principles:**
- **Single Responsibility**: Each component/hook has one job
- **Composition over Inheritance**: Build complex from simple
- **DRY (Don't Repeat Yourself)**: Reuse components and utilities
- **Type Safety**: Use TypeScript for correctness
- **Performance**: Memoize expensive calculations

## Next Steps

**Congratulations!** You've completed all five examples. You now have:

- Understanding of signal generation
- D3.js visualization skills
- React component architecture knowledge
- Code organization best practices

**Continue Learning:**
- Explore the full demo at `/demo/signals`
- Experiment with additional features
- Build your own signal processing applications
- Study advanced D3.js techniques
- Learn about signal processing algorithms

---

**You've completed the Signal Visualization Workshop!** ðŸŽ‰

